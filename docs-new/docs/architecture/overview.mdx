---
sidebar_position: 1
---

# Architecture Overview

SARC-NG system architecture and design overview.

import Mermaid from "@theme/Mermaid";

## System Purpose

SARC-NG (Schedule and Resource Control - Next Generation) is a resource reservation and management API for educational and organizational environments. The system manages buildings, classes, lessons, resources, and reservations with support for scheduling and availability checking.

## Architecture Overview

SARC-NG follows Clean Architecture principles with clear separation of concerns across four main layers:

<Mermaid chart={`
graph TB
    Transport["Transport Layer<br/>(HTTP Handlers, REST API, CLI Commands, Lambda)"]
    Service["Service Layer<br/>(Application Services, Business Use Cases)"]
    Domain["Domain Layer<br/>(Entities, Business Logic, Interfaces)"]
    Adapter["Adapter Layer<br/>(Database, External APIs, Infrastructure)"]

    Transport --> Service
    Service --> Domain
    Adapter --> Domain

    classDef layer fill:#f9f9f9,stroke:#333,stroke-width:1px,color:#333,font-weight:bold;
    class Transport,Service,Domain,Adapter layer;

`}/>

### Key Principles

- **Clean Architecture**: Clear boundaries between layers with dependency inversion
- **Domain-Driven Design**: Business logic encapsulated in domain entities
- **Dependency Injection**: Google Wire for compile-time dependency injection
- **Interface Segregation**: Small, focused interfaces for better testability

## Core Components

### Domain Entities

The system manages five core business entities:

<Mermaid chart={`
classDiagram
    class Building {
        +ID int
        +Name string
        +Code string
        +CreatedAt time
        +UpdatedAt time
    }

    class Class {
        +ID int
        +Name string
        +Capacity int
        +CreatedAt time
        +UpdatedAt time
    }

    class Resource {
        +ID int
        +Name string
        +Type string
        +IsAvailable bool
        +CreatedAt time
        +UpdatedAt time
    }

    class Lesson {
        +ID int
        +Title string
        +Duration int
        +StartTime time
        +EndTime time
        +CreatedAt time
        +UpdatedAt time
    }

    class Reservation {
        +ID int
        +ResourceID int
        +UserID int
        +StartTime time
        +EndTime time
        +Purpose string
        +Status string
        +CreatedAt time
        +UpdatedAt time
    }

    Resource -- Reservation : has many

`}/>

**Building**: Physical structures and locations

- Properties: ID, Name, Code, timestamps
- Purpose: Organize physical spaces for resource allocation

**Class**: Classrooms or physical spaces

- Properties: ID, Name, Capacity, timestamps
- Purpose: Define available spaces for lessons and activities

**Resource**: Bookable resources (rooms, equipment, etc.)

- Properties: ID, Name, Type, Description, IsAvailable, Location, timestamps
- Purpose: Represent reservable items and spaces

**Lesson**: Individual teaching or training sessions

- Properties: ID, Title, Duration, Description, StartTime, EndTime, timestamps
- Purpose: Scheduled educational activities

**Reservation**: Booking records for resources

- Properties: ID, ResourceID, UserID, StartTime, EndTime, Purpose, Status, Description, timestamps
- Purpose: Track resource allocations and prevent conflicts

## Application Layers

### 1. Transport Layer (`internal/transport/`)

Handles external communication and protocol adaptation:

<Mermaid chart={`
graph LR
    Client[Client Applications]
    REST[REST API]
    CLI[CLI Interface]
    Lambda[Lambda Handler]

    Client --> REST
    Client --> CLI
    Client --> Lambda

    subgraph Transport Layer
        REST
        CLI
        Lambda
    end

    REST --> Service[Service Layer]
    CLI --> Service
    Lambda --> Service

    classDef external fill:#f9f9f9,stroke:#333,stroke-width:1px;
    classDef layer fill:#e6f7ff,stroke:#333,stroke-width:1px;

    class Client external;
    class Transport,REST,CLI,Lambda layer;

`}/>

**REST API** (`rest/`):

- Gin-based HTTP handlers for each entity
- DTO mapping for request/response transformation
- Swagger documentation generation
- Middleware for CORS, logging, metrics, recovery

**CLI Interface** (`cmd/cli/`):

- Cobra-based command structure
- Entity-specific commands with formatters
- API client integration for remote operations

**Lambda Handler** (`cmd/lambda/`):

- AWS Lambda integration via Gin adapter
- API Gateway event processing
- Cold start optimization

### 2. Service Layer (`internal/service/`)

Application services implementing business use cases:

- **Building Service**: CRUD operations, validation
- **Class Service**: Space management, capacity tracking
- **Resource Service**: Availability management, type filtering
- **Lesson Service**: Schedule management, time calculations
- **Reservation Service**: Booking logic, conflict detection, availability checking

### 3. Domain Layer (`internal/domain/`)

Core business logic and contracts:

- **Entities**: Domain objects with business rules
- **Use Cases**: Interface definitions for business operations
- **Repositories**: Data access interface contracts

Each domain package contains:

- `entity.go`: Core business entity
- `usecase.go`: Business operation interface
- `repository.go`: Data access interface

### 4. Adapter Layer (`internal/adapter/`)

Infrastructure and external service integration:

<Mermaid chart={`
graph LR
    subgraph Adapter Layer
        GORM[GORM Adapter]
        Config[Configuration Adapter]
    end

    GORM --> DB[(Database)]
    Config --> Files[(Config Files)]
    Config --> Env[(Environment)]

    Domain[Domain Layer] --> GORM
    Domain --> Config

    classDef layer fill:#e6f7ff,stroke:#333,stroke-width:1px;
    classDef external fill:#f9f9f9,stroke:#333,stroke-width:1px;

    class Adapter,GORM,Config layer;
    class DB,Files,Env external;

`}/>

**Database** (`gorm/`):

- GORM-based repository implementations
- MySQL database integration
- Migration support through domain entities

**Configuration** (`config/`):

- Viper-based configuration management
- Environment-specific settings
- Database connection parameters

## Data Flow

### Request Processing

<Mermaid chart={`
sequenceDiagram
    participant Client
    participant Middleware
    participant Handler
    participant Service
    participant Repository
    participant Database

    Client->>Middleware: HTTP Request
    Middleware->>Middleware: Apply CORS/Auth
    Middleware->>Middleware: Add Logging/Metrics
    Middleware->>Handler: Process Request
    Handler->>Handler: Validate & Map DTO→Entity
    Handler->>Service: Execute Business Logic
    Service->>Repository: Access Data
    Repository->>Database: Query
    Database-->>Repository: Result
    Repository-->>Service: Domain Entity
    Service-->>Handler: Process Result
    Handler-->>Handler: Map Entity→DTO
    Handler-->>Middleware: Response
    Middleware-->>Client: HTTP Response

`}/>

## Technology Stack

### Core Technologies

- **Language**: Go 1.24+
- **Web Framework**: Gin (HTTP router, middleware)
- **Database**: MySQL 8.0 with GORM ORM
- **Dependency Injection**: Google Wire (compile-time)
- **Configuration**: Viper with YAML configuration files

### Development Tools

- **Documentation**: Swagger/OpenAPI generation via Swag
- **Testing**: Testify framework for assertions
- **Hot Reloading**: Air for development workflows
- **Linting**: golangci-lint for code quality
- **Debugging**: Delve debugger integration

### Infrastructure

- **Containers**: Docker with multi-stage builds
- **Orchestration**: Docker Compose for local development
- **Cloud**: AWS Lambda, API Gateway, RDS
- **Infrastructure as Code**: Terraform with Terragrunt

## Security Considerations

### Current Implementation

- **CORS**: Configurable cross-origin policies
- **Input Validation**: DTO validation and sanitization
- **SQL Injection**: GORM ORM provides protection
- **Error Handling**: Consistent error responses without data leakage

### Future Enhancements

- **Authentication**: JWT token support prepared in configuration
- **Authorization**: Role-based access control framework
- **Rate Limiting**: Request throttling configuration ready
- **Audit Logging**: Comprehensive operation tracking

## Deployment Options

<Mermaid chart={`
flowchart TD
    subgraph "Deployment Options"
        A[Local Development]
        B[Container]
        C[Serverless]
        D[Traditional]
    end

    A --> A1[Native Go]
    A --> A2[Docker Compose]

    B --> B1[Docker Image]
    B --> B2[Kubernetes]

    C --> C1[AWS Lambda]
    C --> C2[API Gateway]

    D --> D1[Binary + DB]

    classDef option fill:#f9f9f9,stroke:#333,stroke-width:1px;
    classDef deployment fill:#e6f7ff,stroke:#333,stroke-width:1px;

    class A,B,C,D option;
    class A1,A2,B1,B2,C1,C2,D1 deployment;

`}/>

### Local Development

- **Native Go**: Direct execution for fastest development cycle
- **Docker Compose**: Full environment with database and monitoring
- **Hot Reloading**: Air-based automatic recompilation

### Production Deployment

- **Container**: Docker image with distroless base for security
- **Serverless**: AWS Lambda with API Gateway integration
- **Traditional**: Binary deployment with external database
