// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

import (
	"context"
	"fmt"
	"github.com/google/wire"
	"gorm.io/gorm"
	"os"
	"sarc-ng/internal/adapter/db"
	"sarc-ng/internal/adapter/gorm/building"
	"sarc-ng/internal/adapter/gorm/class"
	"sarc-ng/internal/adapter/gorm/lesson"
	"sarc-ng/internal/adapter/gorm/reservation"
	"sarc-ng/internal/adapter/gorm/resource"
	"sarc-ng/internal/adapter/secrets"
	"sarc-ng/internal/config"
	"sarc-ng/internal/domain/auth"
	building3 "sarc-ng/internal/domain/building"
	class3 "sarc-ng/internal/domain/class"
	lesson3 "sarc-ng/internal/domain/lesson"
	reservation3 "sarc-ng/internal/domain/reservation"
	resource3 "sarc-ng/internal/domain/resource"
	auth2 "sarc-ng/internal/service/auth"
	building2 "sarc-ng/internal/service/building"
	class2 "sarc-ng/internal/service/class"
	lesson2 "sarc-ng/internal/service/lesson"
	reservation2 "sarc-ng/internal/service/reservation"
	resource2 "sarc-ng/internal/service/resource"
	"sarc-ng/internal/transport/rest"
)

// Injectors from wire.go:

// InitializeApplication initializes the application with all dependencies
func InitializeApplication() (*Application, error) {
	configConfig, err := config.LoadConfig()
	if err != nil {
		return nil, err
	}
	db, err := provideDatabaseConnection(configConfig)
	if err != nil {
		return nil, err
	}
	gormAdapter := building.NewGormAdapter(db)
	service := building2.NewService(gormAdapter)
	classGormAdapter := class.NewGormAdapter(db)
	classService := class2.NewService(classGormAdapter)
	lessonGormAdapter := lesson.NewGormAdapter(db)
	lessonService := lesson2.NewService(lessonGormAdapter)
	reservationGormAdapter := reservation.NewGormAdapter(db)
	reservationService := reservation2.NewService(reservationGormAdapter)
	resourceGormAdapter := resource.NewGormAdapter(db)
	resourceService := resource2.NewService(resourceGormAdapter)
	jwtValidator := provideTokenValidator(configConfig)
	router := rest.NewRouter(service, classService, lessonService, reservationService, resourceService, jwtValidator)
	application := &Application{
		DB:                 db,
		Config:             configConfig,
		Router:             router,
		BuildingService:    service,
		ClassService:       classService,
		LessonService:      lessonService,
		ResourceService:    resourceService,
		ReservationService: reservationService,
	}
	return application, nil
}

// wire.go:

// Application holds all the application dependencies
type Application struct {
	DB                 *gorm.DB
	Config             *config.Config
	Router             *rest.Router
	BuildingService    building3.Usecase
	ClassService       class3.Usecase
	LessonService      lesson3.Usecase
	ResourceService    resource3.Usecase
	ReservationService reservation3.Usecase
}

// ProviderSet for the application
var ProviderSet = wire.NewSet(config.LoadConfig, provideDatabaseConnection,

	provideTokenValidator, wire.Bind(new(auth.TokenValidator), new(*auth2.JWTValidator)), building.NewGormAdapter, class.NewGormAdapter, lesson.NewGormAdapter, resource.NewGormAdapter, reservation.NewGormAdapter, wire.Bind(new(building3.Repository), new(*building.GormAdapter)), wire.Bind(new(class3.Repository), new(*class.GormAdapter)), wire.Bind(new(lesson3.Repository), new(*lesson.GormAdapter)), wire.Bind(new(resource3.Repository), new(*resource.GormAdapter)), wire.Bind(new(reservation3.Repository), new(*reservation.GormAdapter)), building2.NewService, class2.NewService, lesson2.NewService, resource2.NewService, reservation2.NewService, wire.Bind(new(building3.Usecase), new(*building2.Service)), wire.Bind(new(class3.Usecase), new(*class2.Service)), wire.Bind(new(lesson3.Usecase), new(*lesson2.Service)), wire.Bind(new(resource3.Usecase), new(*resource2.Service)), wire.Bind(new(reservation3.Usecase), new(*reservation2.Service)), rest.NewRouter, wire.Struct(new(Application), "*"),
)

// provideDatabaseConnection provides a database connection using Secrets Manager or config
func provideDatabaseConnection(config2 *config.Config) (*gorm.DB, error) {
	ctx := context.Background()

	secretArn := os.Getenv("DB_SECRET_ARN")

	var dbConfig db.Config
	if secretArn != "" {

		creds, err := secrets.GetDatabaseCredentials(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to get database credentials from Secrets Manager: %w", err)
		}

		dbConfig = db.Config{
			Host:            creds.Host,
			Port:            parsePort(creds.Port),
			User:            creds.Username,
			Password:        creds.Password,
			Database:        creds.Database,
			MaxOpenConns:    config2.Database.MaxOpenConns,
			MaxIdleConns:    config2.Database.MaxIdleConns,
			ConnMaxLifetime: config2.Database.ConnMaxLifetime,
			ConnMaxIdleTime: config2.Database.ConnMaxIdleTime,
		}
	} else {

		dbConfig = db.Config{
			Host:            config2.Database.Host,
			Port:            config2.Database.Port,
			User:            config2.Database.User,
			Password:        config2.Database.Password,
			Database:        config2.Database.Name,
			MaxOpenConns:    config2.Database.MaxOpenConns,
			MaxIdleConns:    config2.Database.MaxIdleConns,
			ConnMaxLifetime: config2.Database.ConnMaxLifetime,
			ConnMaxIdleTime: config2.Database.ConnMaxIdleTime,
		}
	}

	return db.Connect(dbConfig)
}

// parsePort converts string port to int
func parsePort(portStr string) int {
	var port int
	fmt.Sscanf(portStr, "%d", &port)
	if port == 0 {
		port = 3306
	}
	return port
}

// provideTokenValidator creates a new JWT token validator
func provideTokenValidator(cfg *config.Config) *auth2.JWTValidator {
	return auth2.NewJWTValidator(
		cfg.Cognito.Region,
		cfg.Cognito.UserPoolID,
		cfg.Cognito.ClientID,
		cfg.Cognito.JWKSCacheExp,
	)
}
