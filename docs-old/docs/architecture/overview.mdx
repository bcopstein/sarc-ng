---
sidebar_position: 1
---

# Architecture Overview

SARC-NG follows a clean architecture approach to ensure maintainability, testability, and separation of concerns.

import Mermaid from "@theme/Mermaid";

## System Architecture

<Mermaid chart={`
graph TD
    Client[Client Applications] -->|HTTP Requests| API[REST API]

    subgraph "Transport Layer"
        API --> Middleware[Middleware]
        Middleware --> Handlers[HTTP Handlers]
    end

    subgraph "Service Layer"
        Handlers --> Services[Application Services]
    end

    subgraph "Domain Layer"
        Services --> Domain[Domain Logic]
        Domain --> Entities[Entities]
        Domain --> Repositories[(Repository Interfaces)]
    end

    subgraph "Infrastructure Layer"
        Repositories --> DBAdapters[Database Adapters]
        DBAdapters --> DB[(Database)]
    end

`}/>

## Core Principles

SARC-NG is built on the following architectural principles:

1. **Clean Architecture**: Dependencies point inward, with domain at the center
2. **Hexagonal Architecture**: Ports and adapters for external systems
3. **Domain-Driven Design**: Business logic focused in domain entities
4. **Dependency Injection**: Explicit dependencies and testability

## Layer Responsibilities

### Domain Layer

The innermost layer contains business entities, rules, and interfaces:

```go
// Domain entity example
type Building struct {
    ID        uint
    Name      string
    Code      string
    CreatedAt time.Time
    UpdatedAt time.Time
}

// Repository interface
type BuildingRepository interface {
    FindAll() ([]Building, error)
    FindByID(id uint) (*Building, error)
    Create(building *Building) error
    Update(building *Building) error
    Delete(id uint) error
}
```

### Service Layer

Implements use cases by orchestrating domain objects:

```go
// Service example
type BuildingService struct {
    repository domain.BuildingRepository
}

func (s *BuildingService) GetBuilding(id uint) (*domain.Building, error) {
    return s.repository.FindByID(id)
}
```

### Transport Layer

Handles HTTP requests/responses and serialization:

```go
// Handler example
func (h *BuildingHandler) GetBuilding(c *gin.Context) {
    id := c.Param("id")
    buildingID, err := strconv.ParseUint(id, 10, 32)
    if err != nil {
        h.HandleError(c, err)
        return
    }

    building, err := h.service.GetBuilding(uint(buildingID))
    if err != nil {
        h.HandleError(c, err)
        return
    }

    c.JSON(http.StatusOK, h.mapper.ToDTO(building))
}
```

### Infrastructure Layer

Implements adapters to external systems:

```go
// Database adapter example
type GormBuildingRepository struct {
    db *gorm.DB
}

func (r *GormBuildingRepository) FindByID(id uint) (*domain.Building, error) {
    var model Model
    result := r.db.First(&model, id)
    if result.Error != nil {
        return nil, result.Error
    }
    return r.toEntity(model), nil
}
```

## Component Dependencies

<Mermaid chart={`
flowchart TD
    subgraph "Application Entry Points"
        Server["cmd/server"]
        Lambda["cmd/lambda"]
        CLI["cmd/cli"]
    end

    subgraph "Domain Components"
        Building["domain/building"]
        Resource["domain/resource"]
        Class["domain/class"]
        Lesson["domain/lesson"]
        Reservation["domain/reservation"]
    end

    subgraph "Service Layer"
        BuildingSvc["service/building"]
        ResourceSvc["service/resource"]
        ClassSvc["service/class"]
        LessonSvc["service/lesson"]
        ReservationSvc["service/reservation"]
    end

    subgraph "Transport Layer"
        Router["transport/rest/router"]
        BuildingHandler["transport/rest/building"]
        ResourceHandler["transport/rest/resource"]
        ClassHandler["transport/rest/class"]
        LessonHandler["transport/rest/lesson"]
        ReservationHandler["transport/rest/reservation"]
    end

    subgraph "Infrastructure"
        DBAdapter["adapter/db"]
        GormAdapter["adapter/gorm"]
    end

    Server --> Router
    Lambda --> Router

    Router --> BuildingHandler & ResourceHandler & ClassHandler & LessonHandler & ReservationHandler

    BuildingHandler --> BuildingSvc
    ResourceHandler --> ResourceSvc
    ClassHandler --> ClassSvc
    LessonHandler --> LessonSvc
    ReservationHandler --> ReservationSvc

    BuildingSvc --> Building
    ResourceSvc --> Resource
    ClassSvc --> Class
    LessonSvc --> Lesson
    ReservationSvc --> Reservation

    Building & Resource & Class & Lesson & Reservation --> GormAdapter
    GormAdapter --> DBAdapter

`}/>

## Dependency Injection

SARC-NG uses [Wire](https://github.com/google/wire) for compile-time dependency injection:

```go
// Wire provider example
func ProvideHandlers(
    buildingService *service.BuildingService,
    resourceService *service.ResourceService,
    // ... other services
) (*Handler, error) {
    return &Handler{
        buildingService: buildingService,
        resourceService: resourceService,
        // ... other services
    }, nil
}
```

Wire build configuration:

```go
// Wire build
func Initialize() (*Application, error) {
    wire.Build(
        config.ProvideConfig,
        db.ProvideDatabase,
        repository.ProvideRepositories,
        service.ProvideServices,
        handler.ProvideHandlers,
        ProvideApplication,
    )
    return &Application{}, nil
}
```

## API Request Flow

<Mermaid chart={`
sequenceDiagram
    participant Client
    participant Router
    participant Middleware
    participant Handler
    participant Service
    participant Repository
    participant Database

    Client->>Router: HTTP Request
    Router->>Middleware: Process Request
    Middleware->>Handler: Handle Request
    Handler->>Service: Execute Use Case
    Service->>Repository: Data Access
    Repository->>Database: Query/Command
    Database-->>Repository: Results
    Repository-->>Service: Domain Objects
    Service-->>Handler: Domain Response
    Handler-->>Middleware: HTTP Response
    Middleware-->>Router: Process Response
    Router-->>Client: Final Response

`}/>

## Authentication Flow

<Mermaid chart={`
sequenceDiagram
    participant Client
    participant API
    participant Auth
    participant JWT
    participant Service

    Client->>API: Login Request
    API->>Auth: Validate Credentials
    Auth->>JWT: Generate Token
    JWT-->>Auth: JWT Token
    Auth-->>API: Authentication Result
    API-->>Client: JWT Token

    Note over Client,API: Subsequent Requests

    Client->>API: Request with Bearer Token
    API->>JWT: Validate Token
    JWT-->>API: Token Claims
    API->>Service: Authorized Request
    Service-->>API: Response
    API-->>Client: Protected Resource

`}/>

## Next Steps

Now that you understand the architecture:

- [Learn about specific components](components)
- [Explore the API documentation](/api/overview)
- [See deployment options](/deployment/overview)
