---
description: Apply when writing code, refactoring for maintainability, or implementing quality practices across the codebase
alwaysApply: true
---

# Code Quality Standards (SOLID, Clean Code & Design Patterns)

> **PRIORITY**: HIGH - Grounded in proven software engineering principles

## **QUICK REFERENCE**

- Apply Single Responsibility Principle (SRP) - one reason to change per class/function
- Keep functions at single level of abstraction (SLAP) with ≤10 cyclomatic complexity
- Separate commands (side effects) from queries (return values) - Command-Query Separation
- Replace complex conditionals with polymorphism - but only when complexity justifies it
- Write small, focused functions that do one thing well (Clean Code)
- Use meaningful names that reveal intent (Clean Code)
- **Start simple, refactor to patterns when pain emerges (YAGNI)**
- Avoid over-engineering - don't create abstractions for single implementations

## **FOUNDATIONAL PRINCIPLES**

### **SOLID PRINCIPLES**

- Single Responsibility: one reason to change per class/function
- Open-Closed: open for extension, closed for modification
- Command-Query Separation: functions either do something OR return something

### **CLEAN CODE STANDARDS**

- Functions ≤20 lines (max 50), do one thing well
- Descriptive names that explain intent
- Parameters: 0-2 ideal, max 3
- Single level of abstraction per function

### **COMPLEXITY MANAGEMENT**

- Cyclomatic complexity ≤10 per function
- Extract complex logic into separate functions
- Replace long conditionals with polymorphism when justified

## **PRAGMATIC APPLICATION**

### **YAGNI - You Aren't Gonna Need It**

- Apply patterns only when complexity justifies them
- Start simple, refactor to patterns when pain emerges
- Don't create abstractions for single implementations

### **WHEN TO KEEP IT SIMPLE**

- Skip Strategy pattern for 2-3 simple conditions
- Skip Factory pattern for single class creation
- Skip Repository pattern for simple CRUD
- Write straightforward code first, extract patterns during refactoring

### **OVER-ENGINEERING WARNING SIGNS**

- Interfaces with only one implementation
- Unnecessary layers of indirection
- Following patterns without considering context

## **ESSENTIAL PATTERNS**

### **Command-Query Separation**

```python
# CORRECT - CQS
def find_user_by_id(user_id: int) -> User | None:
    """Query - returns user without side effects."""
    return self._repository.find_by_id(user_id)

def update_user_email(user_id: int, email: str) -> None:
    """Command - changes state, returns nothing."""
    user = self._repository.find_by_id(user_id)
    if user is None:
        raise UserNotFoundError(f"User {user_id} not found")
    user.email = email
    self._repository.save(user)

# AVOID - CQS violation
def update_and_get_count(user_id: int, email: str) -> int:
    user = self._repository.find_by_id(user_id)
    user.email = email
    self._repository.save(user)
    return self._repository.count()  # Side effect + return
```

### **Complexity & Pattern Application**

```python
# CORRECT - Low complexity (extract to functions)
def calculate_cost(order: Order) -> Decimal:
    return self._base_cost(order) + self._weight_cost(order) + self._location_cost(order)

# AVOID - High complexity (nested conditions >> 10)
def calculate(order):
    if order.weight > 10:
        if order.country == "US":
            if order.state in ["AK", "HI"]:
                # ... more nesting

# CORRECT - Simple logic stays simple
def get_cost(weight: float, express: bool) -> float:
    return 15.0 if express else (5.0 if weight < 10 else 10.0)

# AVOID - Over-engineering
class TwoOptionStrategyFactory:
    def create_express(self): return ExpressStrategy()
```

## **ENFORCEMENT CHECKLIST**

### **Code Quality**

- [ ] Single Responsibility: one reason to change
- [ ] Command-Query Separation: do OR return, not both
- [ ] Functions ≤20 lines, names reveal intent
- [ ] Parameters: 0-2 ideal, max 3
- [ ] Cyclomatic complexity ≤10
- [ ] Complex conditionals use polymorphism when justified
- [ ] Nested structures ≤3 levels
- [ ] Magic numbers/strings extracted to constants

**CRITICAL**: These principles are proven foundations of maintainable software - they represent decades of collective engineering wisdom!
